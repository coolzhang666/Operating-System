# Linux进程间通信

## 前言

### 进程的概念

1. 进程的定义
    * 进程是程序的一次执行
    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
    * 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    * **进程不等于程序**
2. 进程的基本状态
    * 就绪状态
    * 执行状态
    * 阻塞状态

### 进程通信的概念

* 进程用户空间是独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其他进程之间的互相通信来协调它们的行为。

### 进程通信的应用场景

* 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
* 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立即看到
* 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时需要通知父进程）
* 进程控制：有些进程希望完全控制另外一个进程的执行，此时控制进程希望能够拦截另一个进程的所有的异常并能够及时知道它的状态的改变

### 进程通信的方式

1. 管道
    * 普通管道：用于具有亲缘关系进程间的通信，单工通信
    * 有名管道：可在许多不相关的进程间进行通信

### 管道

1. 管道相关的关键概念
    * 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道
    * 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）
    * 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
    * 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
1. 管道的创建

    ```c
    #include<unistd.h>
    int pipe(int fd[2])
    ```

    * 该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信。

1. 管道的读写规则

    * 管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。

    ```c
    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h>

    int main()
    {
        int pipe_fd[2];
        pid_t pid;
        char r_buf[100];
        char w_buf[100];

        if(pipe(pipe_fd) < 0) // 创建管道
        {
            printf("pipe create error\n");
        }

        pid = fork(); // 创建子进程
        if(pid == -1)
        {
            printf("fork error\n");
        }
        else if(pid == 0)
        {
            close(pipe_fd[1]);
            read(pipe_fd[0], r_buf, 100);
            printf("the data from the pipe is %s\n", r_buf);
        }
        else
        {
            close(pipe_fd[0]);
            sprintf(w_buf, "%s", "hello");
            if(write(pipe_fd[1], w_buf, 5) != -1)
            {
                printf("parent write over\n");
            }
            close(pipe_fd[1]);
            printf("parent close fd[1]\n");
        }

        return 0;
    }
    ```

    * 如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0
    * 当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的数据字节数，如果请求的字节数目不大于PIPE_BUF，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。
    * 向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。
    * 只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。

    ```c
    // 子进程
    close(pipe_fd[0]);
    close(pipe_fd[1]);
    sleep(5);
    ```

    ```c
    // 父进程
    sleep(1);
    close(pipe_fd[0]);
    write(pipe_fd[1], w_buf, strlen(w_buf));
    ```